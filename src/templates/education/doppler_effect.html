{% extends "base.html" %}

{% block title %}多普勒效应演示 - 重庆师范大学师能素质协会{% endblock %}

{% block styles %}
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
<meta name="csrf-token" content="{{ csrf_token() }}">
<style>
    body { font-family: 'Inter', 'Noto Sans SC', sans-serif; background-color: #f0f2f5; color: #334155; }
    .main-container-gradient { background: linear-gradient(145deg, #eef2f7, #ffffff); }
    .display-card { background-color: rgba(255, 255, 255, 0.7); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(0, 0, 0, 0.05); transition: all 0.3s ease; }
    .display-card:hover { transform: translateY(-3px); box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08); }
    .btn { transition: all 0.2s ease-in-out; position: relative; overflow: hidden; will-change: transform; }
    .btn:active { transform: scale(0.97); }
    .btn-start { background-color: #2563eb; color: white; }
    .btn-start:hover { background-color: #1d4ed8; box-shadow: 0 4px 14px rgba(37, 99, 235, 0.25); }
    .btn-stop { background-color: #dc2626; color: white; }
    .btn-stop:hover { background-color: #b91c1c; box-shadow: 0 4px 14px rgba(220, 38, 38, 0.25); }
    .btn:disabled { background-color: #9ca3af; color: #e5e7eb; cursor: not-allowed; box-shadow: none; transform: none; }
    .status-overlay { position: absolute; inset: 0; background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(4px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; transition: opacity 0.3s ease-in-out; border-radius: 0.5rem; }
    .status-overlay.hidden { opacity: 0; pointer-events: none; }
    .spinner { width: 48px; height: 48px; border: 5px solid #e5e7eb; border-top: 5px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 1rem; }
    .ai-spinner { width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .settings-panel { max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out, margin 0.5s ease-in-out; padding-top: 0; padding-bottom: 0; margin-bottom: 0; }
    .settings-panel.show { max-height: 500px; padding-top: 1rem; padding-bottom: 1rem; margin-bottom: 1.5rem; }
    .modal-content { transform: scale(0.95) translateY(20px); opacity: 0; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
    .modal-content.show { transform: scale(1) translateY(0); opacity: 1; }
    #doppler3DScene { width: 100%; height: 100%; display: block; border-radius: 0.5rem; }
    .freq-up, .freq-down { animation: pulse 1s infinite alternate; font-weight: bold; }
    @keyframes pulse { 0% { opacity: 0.7; transform: scale(1); } 100% { opacity: 1; transform: scale(1.1); } }
    #motionStatusText { transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    #motionStatusText.bg-red-100 { animation: approach 1.5s infinite alternate; }
    #motionStatusText.bg-green-100 { animation: retreat 1.5s infinite alternate; }
    @keyframes approach { 0% { transform: translateX(-2px); } 100% { transform: translateX(2px); } }
    @keyframes retreat { 0% { transform: translateX(2px); } 100% { transform: translateX(-2px); } }
</style>
{% endblock %}

{% block content %}
<header class="bg-white/80 backdrop-blur-md sticky top-0 z-50 shadow-sm">
    <nav class="container mx-auto px-6 py-3">
        <div class="flex justify-between items-center">
            <div class="flex items-center">
                <a href="{{ url_for('education.resources') }}" class="bg-blue-600 text-white px-3 py-1 rounded-md mr-4 hover:bg-blue-700 transition-colors">
                    <i class="fas fa-arrow-left mr-1"></i>返回资源
                </a>
                <h1 class="text-xl font-bold text-slate-800">多普勒效应演示</h1>
            </div>
        </div>
    </nav>
</header>

<div class="container mx-auto px-4 py-8">
    <div class="w-full max-w-4xl mx-auto space-y-6">
        <div class="main-container-gradient shadow-xl rounded-2xl p-6 md:p-8">
            <header class="mb-6">
                <h1 class="text-3xl font-bold text-gray-800 text-center">在线一体式多普勒效应演示系统</h1>
                <p class="text-center text-gray-500 mt-2">通过麦克风和AI实时分析声波频率变化来测量和解读运动</p>
            </header>

            <div class="flex flex-wrap gap-4 items-end mb-6">
                <div class="flex-grow min-w-[150px]">
                    <label for="freqInput" class="text-sm font-medium text-gray-700 mb-2 block">发射频率 (Hz)</label>
                    <input type="number" id="freqInput" value="5000" min="1000" max="15000" step="100" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                </div>
                <div class="flex gap-4 items-center flex-wrap">
                    <button id="startButton" class="btn btn-start font-bold py-3 px-6 rounded-lg shadow-md" title="开始测量">开始</button>
                    <button id="stopButton" class="btn btn-stop font-bold py-3 px-6 rounded-lg shadow-md" title="停止测量">停止</button>
                    <button id="showLastResultButton" class="btn bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md" title="查看上次的分析结果">上次结果</button>
                    <button id="settingsToggle" class="btn bg-gray-200 text-gray-700 hover:bg-gray-300 font-bold p-3 rounded-lg shadow-md text-xl" title="高级设置">⚙️</button>
                </div>
            </div>

            <div id="settingsPanel" class="settings-panel">
                 <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">高级设置</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><label for="micGain" class="block text-sm font-medium text-gray-600 mb-1">麦克风增益: <span id="micGainValue" class="font-bold text-blue-600">2.0</span>x</label><input type="range" id="micGain" min="1" max="5" step="0.5" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                        <div><label for="smoothingFactor" class="block text-sm font-medium text-gray-600 mb-1">平滑因子: <span id="smoothingValue" class="font-bold text-blue-600">0.2</span></label><input type="range" id="smoothingFactor" min="0.05" max="0.5" step="0.05" value="0.2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                        <div><label for="fftSize" class="block text-sm font-medium text-gray-600 mb-1">FFT大小</label><select id="fftSize" class="w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-1 focus:ring-blue-500"><option value="8192">8192</option><option value="16384" selected>16384 (高精度)</option><option value="4096">4096 (低延迟)</option></select></div>
                        <div><label for="searchRange" class="block text-sm font-medium text-gray-600 mb-1">搜索范围 (Hz)</label><input type="number" id="searchRange" value="400" min="100" max="1000" step="50" class="w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-1 focus:ring-blue-500"></div>
                        <div><label for="spikeThreshold" class="block text-sm font-medium text-gray-600 mb-1">尖峰阈值 (Hz)</label><input type="number" id="spikeThreshold" value="75" min="10" max="200" step="5" class="w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-1 focus:ring-blue-500"></div>
                    </div>
                </div>
            </div>
            
            <div class="bg-gray-800 p-2 rounded-lg shadow-inner relative h-96 mb-6">
                 <canvas id="doppler3DScene"></canvas>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <div class="display-card p-5 rounded-xl shadow-md flex flex-col items-center justify-center h-full">
                    <h3 class="text-sm font-medium text-gray-500 mb-2">当前检测频率</h3>
                    <div class="flex items-center justify-center">
                        <p id="currentFreqText" class="text-4xl font-semibold text-blue-600">-- Hz</p>
                        <span id="freqTrendArrow" class="ml-3 text-4xl hidden">
                            <span class="freq-up hidden text-red-500">↑</span>
                            <span class="freq-down hidden text-green-500">↓</span>
                        </span>
                    </div>
                </div>
                <div class="display-card p-5 rounded-xl shadow-md flex flex-col items-center justify-center h-full">
                    <h3 class="text-sm font-medium text-gray-500 mb-2">当前相对速度</h3>
                    <div class="flex flex-col items-center">
                        <p id="currentSpeedText" class="text-4xl font-semibold text-green-600">-- m/s</p>
                        <span id="motionStatusText" class="mt-2 px-4 py-1 text-sm font-bold rounded-full hidden"></span>
                    </div>
                </div>
            </div>

            <div class="bg-white p-4 rounded-lg shadow-inner relative">
                <div id="statusOverlay" class="status-overlay hidden"><div class="spinner"></div><p id="statusText" class="text-lg font-medium text-gray-600">正在准备...</p></div>
                <div class="h-72"><canvas id="realtimeChart"></canvas></div>
                <p class="text-xs text-gray-400 text-center mt-2">提示：靠近时速度为正，远离时速度为负。</p>
            </div>
        </div>

        <div class="main-container-gradient shadow-xl rounded-2xl p-6 md:p-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">AI 物理问答</h2>
            <div class="space-y-4">
                <textarea id="aiQuestionInput" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition" rows="3" placeholder="输入你关于多普勒效应或其他物理知识的问题..."></textarea>
                <button id="askAIButton" class="btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg shadow-md">提问</button>
                <div id="aiAnswer" class="text-gray-700 bg-purple-50 p-4 rounded-md min-h-[60px] border border-purple-100">AI 的回答将显示在这里。</div>
            </div>
        </div>
    </div>

    <div id="resultsModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-transparent hidden">
        <div class="bg-white w-full max-w-4xl rounded-2xl shadow-2xl modal-content" id="modalContent">
            <div class="p-6 border-b border-gray-200 flex justify-between items-center">
                <h2 class="text-2xl font-bold text-gray-800">分析结果</h2>
                <button id="closeModalButton" class="text-gray-400 hover:text-gray-600 transition text-3xl leading-none" title="关闭">&times;</button>
            </div>
            <div class="p-6 max-h-[80vh] overflow-y-auto">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="w-full h-64"><canvas id="finalFreqChart"></canvas></div>
                    <div class="w-full h-64"><canvas id="finalSpeedChart"></canvas></div>
                </div>
                <div class="mt-6 bg-blue-50 p-4 rounded-lg">
                    <h3 class="text-lg font-semibold text-blue-800 mb-3">统计数据</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div><p class="text-sm text-gray-500">平均速度</p><p id="avgSpeed" class="text-xl font-semibold text-blue-700">-- m/s</p></div>
                        <div><p class="text-sm text-gray-500">最大靠近速度</p><p id="maxSpeed" class="text-xl font-semibold text-blue-700">-- m/s</p></div>
                        <div><p class="text-sm text-gray-500">最大远离速度</p><p id="minSpeed" class="text-xl font-semibold text-blue-700">-- m/s</p></div>
                        <div><p class="text-sm text-gray-500">有效时长</p><p id="duration" class="text-xl font-semibold text-blue-700">-- 秒</p></div>
                    </div>
                </div>
                 <div class="mt-6 bg-green-50 p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-3">
                         <h3 class="text-lg font-semibold text-green-800">AI 运动模式分析</h3>
                         <button id="aiAnalyzeBtn" class="btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md flex items-center justify-center gap-2">生成分析</button>
                    </div>
                    <div id="aiResult" class="text-green-800 bg-green-100 p-3 rounded-md min-h-[50px]">点击按钮，AI将为你解读详细的运动过程...</div>
                </div>
                <div class="mt-6 text-center">
                    <button id="exportCsvBtn" class="btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg shadow-md">导出为 Excel (CSV) 文件</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- 常量与配置 ---
        // 作用: 定义整个应用中不会改变的基础数值和配置。
        // 可调整参数: 无，这些是基础物理和性能常量。
        const V_SOUND = 343;
        const MAX_CHART_POINTS = 150;
        const UI_UPDATE_INTERVAL = 100;
        const DATA_START_DELAY_MS = 500;
        const NO_SIGNAL_THRESHOLD = 30;
        const GRACE_PERIOD_MS = 1000;

        // --- DOM 元素缓存 ---
        // 作用: 一次性获取所有需要操作的HTML元素，提高性能，避免重复查询。
        // 可调整参数: 无，与HTML结构严格对应。
        const dom = {
            freqInput: document.getElementById('freqInput'),
            startButton: document.getElementById('startButton'),
            stopButton: document.getElementById('stopButton'),
            showLastResultButton: document.getElementById('showLastResultButton'),
            currentFreqText: document.getElementById('currentFreqText'),
            currentSpeedText: document.getElementById('currentSpeedText'),
            statusOverlay: document.getElementById('statusOverlay'),
            statusText: document.getElementById('statusText'),
            settingsToggle: document.getElementById('settingsToggle'),
            settingsPanel: document.getElementById('settingsPanel'),
            micGain: document.getElementById('micGain'),
            micGainValue: document.getElementById('micGainValue'),
            fftSize: document.getElementById('fftSize'),
            smoothingFactor: document.getElementById('smoothingFactor'),
            smoothingValue: document.getElementById('smoothingValue'),
            searchRange: document.getElementById('searchRange'),
            spikeThreshold: document.getElementById('spikeThreshold'),
            resultsModal: document.getElementById('resultsModal'),
            modalContent: document.getElementById('modalContent'),
            closeModalButton: document.getElementById('closeModalButton'),
            avgSpeed: document.getElementById('avgSpeed'),
            maxSpeed: document.getElementById('maxSpeed'),
            minSpeed: document.getElementById('minSpeed'),
            duration: document.getElementById('duration'),
            realtimeChartCanvas: document.getElementById('realtimeChart'),
            finalFreqChartCanvas: document.getElementById('finalFreqChart'),
            finalSpeedChartCanvas: document.getElementById('finalSpeedChart'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            aiAnalyzeBtn: document.getElementById('aiAnalyzeBtn'),
            aiResult: document.getElementById('aiResult'),
            aiQuestionInput: document.getElementById('aiQuestionInput'),
            askAIButton: document.getElementById('askAIButton'),
            aiAnswer: document.getElementById('aiAnswer'),
            threeCanvas: document.getElementById('doppler3DScene'),
        };

        // --- 应用状态管理 ---
        // 作用: 集中管理应用的所有动态变化的状态，方便跟踪和调试。
        // 可调整参数: 无，这些是程序运行时内部状态。
        let state = {
            isRecording: false, appStatus: 'IDLE', audioContext: null, analyser: null,
            microphoneStream: null, oscillator: null, animationFrameId: null,
            dataHistory: [], lastSmoothedFreq: null, startTime: 0,
            finalFilteredData: [], lastUiUpdateTime: 0, noSignalCounter: 0,
            isStabilizing: false, previousFreq: null
        };
        let charts = { realtimeChart: null, finalFreqChart: null, finalSpeedChart: null };
        let threeState = { scene: null, camera: null, renderer: null, waves: [], clock: new THREE.Clock(), lastWaveTime: 0, wavelengthFactor: 1.0, source: null, sourceSpeed: 0, sourceInitialPosition: new THREE.Vector3(-6, 1, 0) };

        // --- 获取用户配置 ---
        // 作用: 从设置面板读取用户配置，供其他函数使用。
        // 可调整参数: 无，此函数只负责读取。
        const getConfig = () => ({
            emittedFreq: parseFloat(dom.freqInput.value),
            micGain: parseFloat(dom.micGain.value),
            fftSize: parseInt(dom.fftSize.value),
            smoothingAlpha: parseFloat(dom.smoothingFactor.value),
            searchRangeHz: parseInt(dom.searchRange.value),
            spikeThresholdHz: parseInt(dom.spikeThreshold.value),
        });

        // --- UI状态机 ---
        // 作用: 根据传入的状态(newStatus)统一更新界面上所有相关元素的显隐和禁用状态。
        // 可调整参数: 无，这是核心UI逻辑。
        function updateUiState(newStatus, message = '') {
            state.appStatus = newStatus;
            dom.startButton.disabled = newStatus !== 'IDLE';
            dom.stopButton.disabled = !(newStatus === 'RECORDING' || newStatus === 'NO_SIGNAL');
            dom.freqInput.disabled = newStatus !== 'IDLE';
            dom.settingsToggle.disabled = newStatus !== 'IDLE';
            dom.showLastResultButton.disabled = newStatus !== 'IDLE' || state.finalFilteredData.length === 0;

            dom.statusOverlay.classList.toggle('hidden', newStatus !== 'PREPARING' && newStatus !== 'STABILIZING');
            if (newStatus === 'PREPARING' || newStatus === 'STABILIZING') dom.statusText.textContent = message;
            
            if (newStatus === 'IDLE' || newStatus === 'PREPARING' || newStatus === 'STABILIZING') {
                dom.currentFreqText.textContent = '-- Hz';
                dom.currentSpeedText.textContent = '-- m/s';
            } else if (newStatus === 'NO_SIGNAL') {
                 dom.currentFreqText.innerHTML = `<span class="text-amber-500 text-2xl">(信号丢失)</span>`;
                 dom.currentSpeedText.textContent = '-- m/s';
            }
        }

        // --- 核心音频处理 ---
        // 作用: 点击"开始"按钮后，初始化所有音频相关的API和节点。
        // 可调整参数: oscillatorGainNode.gain.value (发射音量, 0-1)。
        const start = async () => {
            if (state.isRecording) return;
            updateUiState('PREPARING', '正在初始化音频...');
            await cleanupAudioResources();
            const config = getConfig();
            if (isNaN(config.emittedFreq) || config.emittedFreq <= 0) {
                alert("请输入有效的发射频率。");
                updateUiState('IDLE');
                return;
            }
            Object.assign(state, { dataHistory: [], lastSmoothedFreq: config.emittedFreq, finalFilteredData: [], noSignalCounter: 0, isStabilizing: true });
            
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                updateUiState('PREPARING', '请授权麦克风访问...');
                state.microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                
                const source = state.audioContext.createMediaStreamSource(state.microphoneStream);
                const micGainNode = state.audioContext.createGain();
                micGainNode.gain.value = config.micGain;
                state.analyser = state.audioContext.createAnalyser();
                state.analyser.fftSize = config.fftSize;
                source.connect(micGainNode).connect(state.analyser);

                state.oscillator = state.audioContext.createOscillator();
                const oscillatorGainNode = state.audioContext.createGain();
                state.oscillator.type = 'sine';
                state.oscillator.frequency.setValueAtTime(config.emittedFreq, state.audioContext.currentTime);
                oscillatorGainNode.gain.setValueAtTime(0.5, state.audioContext.currentTime);
                state.oscillator.connect(oscillatorGainNode).connect(state.audioContext.destination);
                
                state.oscillator.start();
                state.isRecording = true;
                state.startTime = performance.now();
                initRealtimeChart();
                updateUiState('STABILIZING', '正在稳定声波...');
                
                setTimeout(() => {
                    if (!state.isRecording) return;
                    state.isStabilizing = false;
                    state.startTime = performance.now();
                    state.dataHistory = [];
                    updateUiState('RECORDING');
                }, DATA_START_DELAY_MS);

                analysisLoop();
            } catch (err) {
                console.error("启动失败:", err);
                alert(`启动失败: ${err.name === 'NotAllowedError' ? '您已拒绝麦克风权限。' : '未找到麦克风或发生错误。'}`);
                await cleanupAudioResources();
                updateUiState('IDLE');
            }
        };

        // 作用: 点击"停止"按钮后，停止分析并显示结果。
        const stop = async () => {
            if (!state.isRecording) return;
            state.isRecording = false;
            cancelAnimationFrame(state.animationFrameId);
            state.finalFilteredData = state.dataHistory;
            showFinalResults();
            await cleanupAudioResources();
            updateUiState('IDLE');
            threeState.sourceSpeed = 0;
        };

        // 作用: 每一帧进行音频数据分析的核心循环。
        // 可调整参数: maxVal < -85 (信号检测灵敏度，越小越灵敏)。
        const analysisLoop = () => {
            if (!state.isRecording) return;
            state.animationFrameId = requestAnimationFrame(analysisLoop);
            try {
                const config = getConfig();
                const freqData = new Float32Array(state.analyser.frequencyBinCount);
                state.analyser.getFloatFrequencyData(freqData);
                const freqPerBin = state.audioContext.sampleRate / config.fftSize;
                const targetBin = Math.round(config.emittedFreq / freqPerBin);
                const searchRadius = Math.round(config.searchRangeHz / 2 / freqPerBin);
                let maxVal = -Infinity, maxIdx = -1;
                for (let i = Math.max(0, targetBin - searchRadius); i <= Math.min(freqData.length - 1, targetBin + searchRadius); i++) {
                    if (freqData[i] > maxVal) { maxVal = freqData[i]; maxIdx = i; }
                }

                if (state.isStabilizing) return;

                const elapsedTime = performance.now() - state.startTime;
                if (maxIdx === -1 || maxVal < -85) {
                    if (elapsedTime > GRACE_PERIOD_MS) {
                        state.noSignalCounter++;
                        if (state.noSignalCounter > NO_SIGNAL_THRESHOLD && state.appStatus !== 'NO_SIGNAL') {
                            updateUiState('NO_SIGNAL');
                        }
                    }
                    threeState.sourceSpeed = 0;
                    return;
                }
                if (state.appStatus === 'NO_SIGNAL') updateUiState('RECORDING');
                state.noSignalCounter = 0;
                let totalPower = 0, weightedFreq = 0;
                for (let i = Math.max(0, maxIdx - 3); i <= Math.min(freqData.length - 1, maxIdx + 3); i++) {
                    const power = Math.pow(10, freqData[i] / 10);
                    totalPower += power;
                    weightedFreq += power * i * freqPerBin;
                }
                const detectedFreq = totalPower > 0 ? weightedFreq / totalPower : maxIdx * freqPerBin;
                const diff = detectedFreq - state.lastSmoothedFreq;
                const smoothedFreq = Math.abs(diff) > config.spikeThresholdHz
                    ? state.lastSmoothedFreq + Math.sign(diff) * config.spikeThresholdHz
                    : config.smoothingAlpha * detectedFreq + (1 - config.smoothingAlpha) * state.lastSmoothedFreq;
                state.lastSmoothedFreq = smoothedFreq;
                const speed = calculateSpeed(smoothedFreq, config.emittedFreq);
                const currentTime = (performance.now() - state.startTime) / 1000;
                state.dataHistory.push({ t: currentTime, f: smoothedFreq, v: speed });
                if (performance.now() - state.lastUiUpdateTime > UI_UPDATE_INTERVAL) {
                    updateLiveUI(smoothedFreq, speed, currentTime);
                    state.lastUiUpdateTime = performance.now();
                }
                threeState.wavelengthFactor = config.emittedFreq / smoothedFreq;
                threeState.sourceSpeed = speed;
            } catch (error) {
                console.error("分析循环出错:", error);
                stop();
            }
        };
        
        // 作用: 安全地关闭和释放所有音频资源。
        async function cleanupAudioResources() {
            if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
            if (state.oscillator) { try { state.oscillator.stop(); } catch (e) {} state.oscillator.disconnect(); }
            if (state.microphoneStream) { state.microphoneStream.getTracks().forEach(track => track.stop()); }
            if (state.analyser) { state.analyser.disconnect(); }
            if (state.audioContext && state.audioContext.state !== 'closed') { await state.audioContext.close(); }
            Object.assign(state, { isRecording: false, audioContext: null, analyser: null, microphoneStream: null, oscillator: null, animationFrameId: null });
        }

        // 作用: 根据多普勒效应公式计算速度。
        function calculateSpeed(observedFreq, emittedFreq) { return V_SOUND * (observedFreq / emittedFreq - 1); }

        // --- 结果显示、图表、导出 ---
        // 作用: 停止测量后，计算统计数据并显示结果弹窗。
        function showFinalResults() {
            const data = state.finalFilteredData;
            if (data.length < 10) {
                if (state.dataHistory.length > 0) alert(`有效数据不足 (少于10个点)，无法生成报告。`);
                updateUiState('IDLE');
                return;
            }
            const speeds = data.map(d => d.v);
            const positiveSpeeds = speeds.filter(s => s > 0);
            const negativeSpeeds = speeds.filter(s => s < 0);
            dom.avgSpeed.textContent = `${(speeds.reduce((a, b) => a + b, 0) / speeds.length).toFixed(2)} m/s`;
            dom.maxSpeed.textContent = `${(positiveSpeeds.length ? Math.max(...positiveSpeeds) : 0).toFixed(2)} m/s`;
            dom.minSpeed.textContent = `${(negativeSpeeds.length ? Math.min(...negativeSpeeds) : 0).toFixed(2)} m/s`;
            dom.duration.textContent = `${(data[data.length - 1].t).toFixed(1)} 秒`;
            dom.aiResult.innerHTML = '点击按钮，AI将为你解读详细的运动过程...';
            resetButton(dom.aiAnalyzeBtn, '生成分析');
            dom.resultsModal.classList.remove('hidden');
            setTimeout(() => {
                dom.modalContent.classList.add('show');
                renderFinalCharts(data);
            }, 50);
        }

        // 作用: 在结果弹窗中渲染最终的频率和速度图表。
        function renderFinalCharts(data) {
            const emittedFreq = getConfig().emittedFreq;
            const freqData = data.map(d => ({ x: d.t, y: d.f }));
            const speedData = data.map(d => ({ x: d.t, y: d.v }));
            const timeRange = { min: data.length ? data[0].t : 0, max: data.length ? data[data.length - 1].t : 1 };
            const chartBaseOptions = {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: { x: { type: 'linear', ...timeRange, title: { display: true, text: `时间 (s)` } } },
                plugins: { legend: { display: true, position: 'top' }, tooltip: { mode: 'index', intersect: false } },
                elements: { point: { radius: 0 }, line: { tension: 0.1, borderWidth: 2 } }
            };
            const datasets = {
                freq: [{ label: '检测频率', data: freqData, borderColor: '#2563eb' }, { label: '发射频率', data: [{x: timeRange.min, y: emittedFreq}, {x: timeRange.max, y: emittedFreq}], borderColor: '#dc2626', borderDash: [5, 5] }],
                speed: [{ label: '相对速度', data: speedData, borderColor: '#16a34a' }, { label: '静止', data: [{x: timeRange.min, y: 0}, {x: timeRange.max, y: 0}], borderColor: '#6b7280', borderDash: [5, 5] }]
            };
            if (charts.finalFreqChart) charts.finalFreqChart.destroy();
            charts.finalFreqChart = new Chart(dom.finalFreqChartCanvas.getContext('2d'), { type: 'line', data: { datasets: datasets.freq }, options: { ...chartBaseOptions, plugins: {...chartBaseOptions.plugins, title: {display: true, text: '频率 vs 时间'}}, scales: { ...chartBaseOptions.scales, y: { title: { display: true, text: '频率 (Hz)' } } } } });
            if (charts.finalSpeedChart) charts.finalSpeedChart.destroy();
            charts.finalSpeedChart = new Chart(dom.finalSpeedChartCanvas.getContext('2d'), { type: 'line', data: { datasets: datasets.speed }, options: { ...chartBaseOptions, plugins: {...chartBaseOptions.plugins, title: {display: true, text: '速度 vs 时间'}}, scales: { ...chartBaseOptions.scales, y: { title: { display: true, text: '速度 (m/s)' } } } } });
        }
        
        // 作用: 更新主界面上的实时数据和图表。
        function updateLiveUI(freq, speed, time) {
            if (state.appStatus === 'RECORDING') {
                dom.currentFreqText.textContent = `${freq.toFixed(1)} Hz`;
                dom.currentSpeedText.textContent = `${speed.toFixed(2)} m/s`;
                
                const freqTrendArrow = document.getElementById('freqTrendArrow');
                const freqUpArrow = freqTrendArrow.querySelector('.freq-up');
                const freqDownArrow = freqTrendArrow.querySelector('.freq-down');
                
                // 更新频率趋势箭头
                if (state.previousFreq !== null) {
                    const freqDiff = freq - state.previousFreq;
                    const emittedFreq = getConfig().emittedFreq;
                    
                    // 显示箭头的阈值，可以根据需要调整
                    const threshold = Math.max(0.5, emittedFreq * 0.0002);
                    
                    if (Math.abs(freqDiff) >= threshold) {
                        freqTrendArrow.classList.remove('hidden');
                        
                        // 频率上升（靠近）显示向上箭头
                        if (freqDiff > 0) {
                            freqUpArrow.classList.remove('hidden');
                            freqDownArrow.classList.add('hidden');
                        } 
                        // 频率下降（远离）显示向下箭头
                        else {
                            freqUpArrow.classList.add('hidden');
                            freqDownArrow.classList.remove('hidden');
                        }
                    } else {
                        // 频率变化不明显，隐藏箭头
                        freqTrendArrow.classList.add('hidden');
                    }
                } else {
                    // 首次测量，没有前值比较，隐藏箭头
                    freqTrendArrow.classList.add('hidden');
                }
                
                // 保存当前频率用于下次比较
                state.previousFreq = freq;
                
                const motionStatusText = document.getElementById('motionStatusText');
                if (Math.abs(speed) < 0.2) {
                    motionStatusText.textContent = '静止';
                    motionStatusText.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
                    motionStatusText.classList.add('bg-gray-100', 'text-gray-800');
                } else if (speed > 0) {
                    motionStatusText.textContent = '靠近中';
                    motionStatusText.classList.remove('hidden', 'bg-gray-100', 'text-gray-800', 'bg-green-100', 'text-green-800');
                    motionStatusText.classList.add('bg-red-100', 'text-red-800');
                } else {
                    motionStatusText.textContent = '远离中';
                    motionStatusText.classList.remove('hidden', 'bg-gray-100', 'text-gray-800', 'bg-red-100', 'text-red-800');
                    motionStatusText.classList.add('bg-green-100', 'text-green-800');
                }
            }
            
            const chart = charts.realtimeChart;
            if (!chart) return;
            const freqData = chart.data.datasets[0].data;
            freqData.push({ x: time, y: freq });
            if (freqData.length > MAX_CHART_POINTS) freqData.shift();
            const firstX = freqData.length > 0 ? freqData[0].x : 0;
            chart.data.datasets[1].data = [{ x: firstX, y: getConfig().emittedFreq }, { x: time, y: getConfig().emittedFreq }];
            chart.update('none');
        }

        // 作用: 初始化实时图表。
        function initRealtimeChart() {
            if (charts.realtimeChart) charts.realtimeChart.destroy();
            const emittedFreq = getConfig().emittedFreq;
            const ctx = dom.realtimeChartCanvas.getContext('2d');
            charts.realtimeChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: [ { label: '检测频率', data: [], borderColor: 'rgba(37, 99, 235, 1)', backgroundColor: 'rgba(37, 99, 235, 0.1)', fill: true, }, { label: '发射频率', data: [], borderColor: 'rgba(220, 38, 38, 0.7)', borderDash: [5, 5], } ] },
                options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { type: 'linear', title: { display: true, text: '时间 (s)' } }, y: { type: 'linear', title: { display: true, text: '频率 (Hz)' }, suggestedMin: emittedFreq - 15, suggestedMax: emittedFreq + 15 } }, plugins: { legend: { display: true, position: 'top' }, tooltip: { enabled: false } }, elements: { point: { radius: 0 }, line: { borderWidth: 2, tension: 0.4 } } }
            });
        }

        // 作用: 将测量数据导出为CSV文件。
        function exportToCsv() {
            if (state.finalFilteredData.length === 0) { alert("没有可导出的数据。"); return; }
            const headers = '"Time (s)","Detected Frequency (Hz)","Relative Speed (m/s)"';
            const rows = state.finalFilteredData.map(d => `"${d.t.toFixed(3)}","${d.f.toFixed(2)}","${d.v.toFixed(2)}"`);
            const csvContent = `${headers}\n${rows.join('\n')}`;
            const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `doppler_effect_data_${new Date().toISOString()}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- AI 相关功能 ---
        // 作用: 将连续的速度数据分割成"靠近"、"远离"、"静止"等有意义的片段。
        function segmentMovementData(data) {
            const segments = [];
            if (data.length < 5) return "";
            const speedThreshold = 0.15;
            let currentSegment = { state: '静止', startTime: data[0].t, speeds: [] };
            const getState = (speed) => {
                if (speed > speedThreshold) return '靠近';
                if (speed < -speedThreshold) return '远离';
                return '静止';
            };
            data.forEach(point => {
                const newState = getState(point.v);
                if (newState !== currentSegment.state) {
                    if (currentSegment.speeds.length > 0) {
                        currentSegment.endTime = point.t;
                        segments.push(currentSegment);
                    }
                    currentSegment = { state: newState, startTime: point.t, speeds: [point.v] };
                } else {
                    currentSegment.speeds.push(point.v);
                }
            });
            currentSegment.endTime = data[data.length - 1].t;
            segments.push(currentSegment);
            return segments.map(seg => {
                const duration = seg.endTime - seg.startTime;
                if (duration < 0.3) return null;
                let description = seg.state;
                if (seg.state !== '静止') {
                    const avgSpeed = Math.abs(seg.speeds.reduce((a, b) => a + b, 0) / seg.speeds.length);
                    if (avgSpeed > 1.5) description = `快速${description}`;
                    else if (avgSpeed < 0.5) description = `缓慢${description}`;
                }
                return `从 ${seg.startTime.toFixed(1)}秒 到 ${seg.endTime.toFixed(1)}秒, 物体${description}。`;
            }).filter(Boolean).join(' ');
        }
        
        // 作用: 设置按钮为加载状态。
        async function setButtonLoading(button, text) {
            button.disabled = true;
            button.innerHTML = `<div class="flex items-center justify-center"><div class="ai-spinner mr-2"></div><span>${text}</span></div>`;
        }

        // 作用: 恢复按钮的原始状态。
        function resetButton(button, originalText) {
            button.disabled = false;
            button.innerHTML = originalText;
        }

        // 作用: 请求AI对运动数据进行分析。
        async function generateAiAnalysis() {
            const originalText = dom.aiAnalyzeBtn.innerHTML;
            await setButtonLoading(dom.aiAnalyzeBtn, '分析中...');
            const segmentedSummary = segmentMovementData(state.finalFilteredData);
            if (!segmentedSummary) {
                dom.aiResult.textContent = "未能识别出明显的运动片段，可能是移动幅度过小或时间过短。";
                resetButton(dom.aiAnalyzeBtn, originalText);
                return;
            }
            const prompt = `根据以下运动摘要，直接用通俗、连贯的语言总结运动过程，不要添加任何多余的前言。摘要：${segmentedSummary}`;
            try {
                const text = await callGeminiAPI(prompt);
                dom.aiResult.textContent = text;
            } catch (error) {
                dom.aiResult.textContent = `分析失败: ${error.message}`;
            } finally {
                resetButton(dom.aiAnalyzeBtn, originalText);
            }
        }

        // 作用: 请求AI回答用户提出的问题。
        async function askAiQuestion() {
            const question = dom.aiQuestionInput.value.trim();
            if (!question) { alert("请输入您的问题。"); return; }
            const originalText = dom.askAIButton.innerHTML;
            await setButtonLoading(dom.askAIButton, '思考中...');
            try {
                const prompt = `请直接、简洁地回答以下中文物理问题：${question}`;
                const text = await callGeminiAPI(prompt);
                dom.aiAnswer.textContent = text;
            } catch (error) {
                dom.aiAnswer.textContent = `回答失败: ${error.message}`;
            } finally {
                resetButton(dom.askAIButton, originalText);
            }
        }

        // 作用: 调用后端API与Gemini模型交互。
        async function callGeminiAPI(prompt) {
            const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
            const apiUrl = "{{ url_for('education.gemini_api') }}";
            const response = await fetch(apiUrl, { 
                method: 'POST', 
                headers: { 
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                }, 
                body: JSON.stringify({ prompt: prompt }) 
            });
            
            if (!response.ok) throw new Error(`API请求失败，状态码: ${response.status}`);
            const result = await response.json();
            
            if (result.success && result.content) {
                return result.content;
            } else {
                throw new Error(result.content || "AI未能生成有效的回复。");
            }
        }

        // --- 3D 可视化 ---
        // 作用: 初始化3D场景、相机、渲染器和光照。
        // 可调整参数: camera.position (相机位置), gridHelper (网格大小和颜色)。
        function init3D() {
            const container = dom.threeCanvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;

            threeState.scene = new THREE.Scene();
            threeState.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            threeState.camera.position.set(0, 6, 12); // 拉近相机
            threeState.camera.lookAt(0, 2, 0);

            threeState.renderer = new THREE.WebGLRenderer({ canvas: dom.threeCanvas, antialias: true, alpha: true });
            threeState.renderer.setSize(width, height);
            threeState.renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            threeState.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 15, 10);
            threeState.scene.add(directionalLight);
            
            const gridHelper = new THREE.GridHelper(40, 40, 0x555555, 0x333333);
            threeState.scene.add(gridHelper);

            createModels();
            animate3D();

            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                threeState.camera.aspect = newWidth / newHeight;
                threeState.camera.updateProjectionMatrix();
                threeState.renderer.setSize(newWidth, newHeight);
            });
        }

        // 作用: 创建3D场景中的扬声器和观察者模型。
        // 可调整参数: 各种模型的几何形状(Geometry)和材质(Material)。
        function createModels() {
            // 扬声器 (Source)
            const speakerGroup = new THREE.Group();
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6, metalness: 0.2 });
            const speakerBox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.2), boxMat);
            const coneMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4 });
            const speakerCone = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 0.5, 32), coneMat);
            speakerCone.position.z = 0.61;
            speakerCone.rotation.x = Math.PI / 2;
            const coneRing = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.05, 16, 100), new THREE.MeshStandardMaterial({ color: 0x555555 }));
            coneRing.position.z = 0.61;
            coneRing.rotation.x = Math.PI / 2;
            speakerGroup.add(speakerBox, speakerCone, coneRing);
            speakerGroup.position.copy(threeState.sourceInitialPosition);
            threeState.scene.add(speakerGroup);
            threeState.source = speakerGroup;

            // 观察者 (Observer)
            const observerGroup = new THREE.Group();
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x4a5568, roughness: 0.5 });
            const screenMat = new THREE.MeshStandardMaterial({ color: 0x3a4558, roughness: 0.5 });
            
            const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2.2), baseMat);
            base.position.y = 0.1;

            const hinge = new THREE.Group();
            base.add(hinge);
            hinge.position.z = -1;

            const screen = new THREE.Mesh(new THREE.BoxGeometry(3, 2.2, 0.15), screenMat);
            screen.position.y = 1.1;
            hinge.add(screen);
            hinge.rotation.x = Math.PI / 2.5;

            const receiverMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const receiver = new THREE.Mesh(new THREE.CircleGeometry(0.3, 32), receiverMat);
            receiver.position.z = 0.08; 
            screen.add(receiver);

            observerGroup.add(base);
            observerGroup.position.set(6, 0, 0); // 调整初始距离
            threeState.scene.add(observerGroup);
        }

        // 作用: 3D场景的动画循环，负责更新物体位置和声波动画。
        function animate3D() {
            requestAnimationFrame(animate3D);
            const now = performance.now();
            const delta = threeState.clock.getDelta();

            // 更新声源位置
            if (threeState.source) {
                if (state.isRecording) {
                    // 可调整参数: * 4 (声源移动速度的视觉倍率)
                    threeState.source.position.x += threeState.sourceSpeed * delta * 4;
                    threeState.source.position.x = THREE.MathUtils.clamp(threeState.source.position.x, -10, 4);
                } else {
                    // 平滑返回初始位置
                    threeState.source.position.lerp(threeState.sourceInitialPosition, 0.05);
                }
            }

            // 创建声波
            // 可调整参数: 150 (声波生成频率，越小越快)
            if (state.isRecording && !state.isStabilizing && (now - threeState.lastWaveTime > 150 * threeState.wavelengthFactor)) {
                threeState.lastWaveTime = now;
                
                const points = new THREE.Path().absarc(0, 0, 0.1, 0, Math.PI * 2, false).getPoints(64);
                const waveGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const waveMaterial = new THREE.LineBasicMaterial({ color: 0x34d399, transparent: true });
                
                const wave = new THREE.LineLoop(waveGeometry, waveMaterial);
                
                wave.position.copy(threeState.source.position);
                wave.rotation.x = Math.PI / 2;
                wave.userData.creationTime = now;
                threeState.scene.add(wave);
                threeState.waves.push(wave);
            }

            // 更新声波动画
            threeState.waves.forEach((wave, index) => {
                const age = (now - wave.userData.creationTime) / 1000;
                const radius = age * 30; // 可调整参数：声波扩散速度
                wave.scale.set(radius, radius, radius);
                
                const fadeStartRadius = 25; // 可调整参数：开始消失的半径
                const maxRadius = 200; // 可调整参数：完全消失的半径
                if (radius > fadeStartRadius) {
                    wave.material.opacity = 1.0 - (radius - fadeStartRadius) / (maxRadius - fadeStartRadius);
                }

                if (wave.material.opacity <= 0) {
                    threeState.scene.remove(wave);
                    wave.geometry.dispose();
                    wave.material.dispose();
                    threeState.waves.splice(index, 1);
                }
            });

            threeState.renderer.render(threeState.scene, threeState.camera);
        }

        // --- 应用初始化 ---
        // 作用: 绑定所有事件监听器，并初始化UI和3D场景。
        function init() {
            dom.startButton.addEventListener('click', start);
            dom.stopButton.addEventListener('click', stop);
            dom.showLastResultButton.addEventListener('click', showFinalResults);
            dom.settingsToggle.addEventListener('click', () => dom.settingsPanel.classList.toggle('show'));
            dom.smoothingFactor.addEventListener('input', (e) => dom.smoothingValue.textContent = parseFloat(e.target.value).toFixed(2));
            dom.micGain.addEventListener('input', (e) => dom.micGainValue.textContent = `${parseFloat(e.target.value).toFixed(1)}x`);
            dom.closeModalButton.addEventListener('click', () => {
                dom.modalContent.classList.remove('show');
                setTimeout(() => dom.resultsModal.classList.add('hidden'), 300);
            });
            dom.exportCsvBtn.addEventListener('click', exportToCsv);
            dom.aiAnalyzeBtn.addEventListener('click', generateAiAnalysis);
            dom.askAIButton.addEventListener('click', askAiQuestion);
            window.addEventListener('beforeunload', cleanupAudioResources);
            updateUiState('IDLE');
            initRealtimeChart();
            init3D();
        }

        init();
    });
    </script>
</div>
{% endblock %}
